# 一、测试环境准备

## 1、服务器配置信息

![服务器配置信息](/images/mvc/服务器配置信息.png)

- 服务器：阿里云ECS云服务器
- 运行系统：CentOS 7.3 64位
- CPU：1 vCPU
- 内存：2GB(IO优化)
- 带宽：1MBbps
- JDK：1.8.0_151
- JVM：Java HotSpot(TM) 64-Bit Server VM

## 2、被测试项目信息

### 1、项目名：

​	graduation-project-mvc

### 2、项目介绍：

- 用途：

  ​	传统MVC架构的内容管理系统项目，采用前后端分离技术，可通过后台管理系统的操作对前台显示的相关信息进行管理（增删改查），提供权限动态分配、用户管理、内容模糊查询等功能。

- 特点：**权限动态分配、前后端分离**。

- 说明：**简单的MVC+权限认证项目，没有缓存，除了主键外没有其他索引**。

- 相关技术及工具：

  - 技术：
    - 主体架构：SpringBoot、SpringMvc、Mybatis
    - 权限控制：SpringSecurity
    - 数据库：Docker-MySql
    - 前端：JavaScript、JQuery、BootStrop、Layui、Html/CSS等。
    - 前后端交互：Ajax、Json
    - 监控：SpringBootAdmin、Alibaba-Druid
  - 工具：
    - 结构控制：Maven
    - 版本控制：Git/Github
    - 设计与画图：processon、PowerDesigner、Navicat。

### 3、项目结构

![毕设架构-单体MVC](/images/mvc/毕设架构-单体MVC.png)

### 4、主要模块的数据库设计：

- 用户与权限模块

  ![用户-权限模块](/images/mvc/用户-权限模块.png)

- 留言模块

  ![用户留言模块](/images/mvc/用户留言模块.png)

- 内容发布模块

  ![](/images/mvc/内容发布模块.png)

## 3、测试前信息

### 1、待测试接口

- 新闻列表：http://120.78.59.162:8081/newsInfo/list?currentPage=1&rows=10&condition=%7B%22searchContent%22%3A%22%22%7D
  - 说明：查询首页数据，从第 1 条查到第 10 条，condition后面表示模糊查询条件，默认为 null。

### 2、待测试接口所涉及到的数据库表结构

- 新闻信息表【除了主键外，无其他索引】

  ![](/images/mvc/新闻信息表.png)

### 3、待测试接口所涉及的SQL语句

- 新闻列表（http://120.78.59.162:8081/newsInfo/list?currentPage=1&rows=10&condition=%7B%22searchContent%22%3A%22%22%7D）：

  - 分页查新闻信息

  ```mysql
  SELECT id,title,imgs,content,remarks,create_user_id,create_date,update_user_id,update_date
  FROM tab_news_info
  ORDER BY create_date DESC
  LIMIT 0,10
  ```


### 4、测试接口的对应的表的数据量

​	![](/images/mvc/单表数据量.png)

- 查询可知，新闻列表的单表数据量为 **1600** 条。

### 5、环境配置信息

- 德鲁伊（Druid）数据源配置信息

  ```yaml
  druid:
        # 初始化大小，最小，最大
        initial-size: 5
        min-idle: 5
        max-active: 2000
        # 配置获取连接等待超时的时间
        max-wait: 60000
       # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
        time-between-eviction-runs-millis: 60000
        # 配置一个连接在池中最小生存的时间，单位是毫秒
        min-evictable-idle-time-millis: 300000
        validation-query: SELECT 1 FROM DUAL
        test-while-idle: true
        test-on-borrow: false
        test-on-return: false
        # 打开PSCache，并且指定每个连接上PSCache的大小
        pool-prepared-statements: true
        #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
        max-pool-prepared-statement-per-connection-size: 20
        # SpringBoot 2.x 此处记得去掉 log4j
        filters: stat,wall
        use-global-data-source-stat: true
        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
        connect-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
        # 配置监控服务器
        stat-view-servlet:
          login-username: admin
          login-password: 你的密码
          reset-enable: false
          url-pattern: /druid/*
          # 添加IP白名单
          #allow:
          # 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高
          #deny:
        web-stat-filter:
          # 添加过滤规则
          url-pattern: /*
          # 忽略过滤格式，一定要加上 ""，否则会报错
          exclusions: "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"
  ```

- JVM配置信息

  默认。

# 二、并发测试

### 1、并发测试理论依据

理论来源【[**JMeter之Ramp-up Period（in seconds）说明**](https://www.cnblogs.com/hjhsysu/p/9189897.html)】

```
假设：

线程数：n
Ramp-Up Period：T （有人称之为启动时间，有人说是准备时长，看个人喜好）
循环次数：a  
若每个循环运行时间是：t

当时间到 S = (T- T/n)时，最后一个线程启动，若要使所有线程同时运作，则需要在最后一个线程启动的时候第一个线程仍未关闭，为达到这个要求，需满足 a·t > S及a > S/t

每一个个线程运行时间既是R = a·t(此处的a是大于S/t的某一值)，则第一个线程在时间点为R 的时候停止，整个测试理论运行时间则是 ：S + R = (1-1/n)·T + a·t

总结：
测试中变量是 线程数 n ，每个循环时间 t 是个实践值，循环次数 a 只是为了延长单个线程的运行时间，从而保证当最后一个线程启动时，所有线程都在运行中，达到压测效果。
```

### 2、接口测试

#### 1、测试前

- 根据测试理论获取首页的平均响应时间

  - JMeter预先配置

    - 线程组配置

    ![](/images/mvc/getAvgTime/JMeter-新闻列表-获取平均响应时间-线程组配置.png)

    说明：

    ​	1、线程数：5 个

    ​	2、总启动时间：10 s

    ​	3、每个线程的循环次数： 3 次

    

    - Http请求配置

      ![](/images/mvc/getAvgTime/JMeter-新闻列表-获取平均响应时间-HTTP配置.png)

      说明：

      ​	1、请求协议：HTTP

      ​	2、请求服务器IP：120.78.59.162

      ​	3、请求端口号：8081

      ​	4、请求方法：GET

      ​	5、请求URL：/newsInfo/list?currentPage=1&rows=10&condition=%7B%22searchContent%22%3A%22%22%7D

      ​	6、响应内容编码：UTF-8

    - 聚合报告

      ![](/images/mvc/getAvgTime/JMeter-新闻列表-获取平均响应时间-聚合报告.png)

    - 结果分析：

      由聚合报告可知，请求URL的平均响应时间为：234.030s

      由上面配置信息可知：

      ​	启动时间T：10

      ​	线程数n：5

      ​	由理论计算公式可得：S = (T- T/n) = (10-10/5)=8

      也就是说，从第一个线程启动到第8秒的时候，最后一个线程开始启动，若需要在最后一个线程启动的时候第一个线程仍未关闭，则需要满足 a·t > S ，已知S = 8，t = 234.030，得到 a > 0.034 ，**即循环次数只要大于0.034次，就能保证所有线程并发访问测试接口**。

      为了方便起见，我就把循环设置成1，那么单个线程运行时间就是R = a·t = 234.030≈234秒，也就是说第一个线程会在第234秒的时候停止，单个测试的理论运行时间为 S + R = (1-1/n)·T + a·t ≈ 242秒。

      **也就是说，若按上面的测试数据，只有从第8s开始，到第242秒的测试时间里，才是真正的模拟5个用户同时并发。**

      若线程数为10，则并发时间段为：第9秒到第242秒。

    - 总结：

      ​	**接口响应太慢，只需把循环次数设为1次就能保证所有线程并发访问接口。**

      

  - 测试前信息

    - 德鲁伊-URL信息

    ![](/images/mvc/before/URL信息.png)

    说明：

    1. 请求URL：/newsInfo/list

    2. 请求次数：16（以往的数据）

    3. 请求时间和：3545878 ms

    4. 最慢一次请求耗时：255670 ms

    5. 执行中的线程：0

    6. 最大并发数：5

    7. jdbc总次数：32

    8. jdbc总耗时：3531258 ms

       

    - 德鲁伊-SQL信息

    ![](/images/mvc/before/SQL信息.png)

    说明：

    1. 查询sql：

       ```mysql
       SELECT id, title, imgs, content, remarks, create_user_id, create_date, update_user_id,update_date
       FROM tab_news_info
       ORDER BY create_date DESC
       ```

    2. 执行数：16（以往数据）

    3. 总执行时间：3506822 ms

    4. 最慢一次查询耗时：252982 ms

    5. 执行中的线程：0

    6. 最大并发数：5

       

    - BootAdmin-堆内存信息

    ![](/images/mvc/before/堆内存信息.png)

    说明：

    ​	JAVA堆：

    ​		**1、当前堆内存：257MB**

    ​		**2、当前堆内存使用：130MB**

    ​		**3、最大堆内存：466MB**

    ​		**4、堆内存使用线：呈锯齿型**

    ​	非堆（方法区）：

    ​		**1、元空间（METASPACE）内存：71.3MB**

    ​		**2、当前非堆内存：117MB**

    ​		**3、当前非堆内存使用：112MB**

    ​		**4、最大非堆内存：存1.33GB**

    ​		**5、堆内存使用线：基本是直线型**

    - BootAdmin-GC信息

    ![](/images/mvc/before/GC信息.png)

    ​	说明：

    ​		1、GC总次数：194

    ​		2、GC总耗时：3.0000 s

    ​		3、最慢一次GC耗时：0.0080s

    

    - BootAdmin-线程信息

    ![](/images/mvc/before/线程信息.png)

    ​	说明：

    ​		1、当前运行线程：28

    ​		2、守护线程：22

    ​		3、顶峰运行线程：29

    

    - BootAdmin-CPU信息

    ![](/images/mvc/before/CPU信息.png)

    ​	说明：

    ​		1、进程ID：1505

    ​		2、CPU使用率：6%

    

    - ECS服务器信息

    ![](/images/mvc/before/ECS信息.png)

#### 2、测试时

- 前提：

  ​	在获取新闻列表的平均响应时间时，发现平均响应速度竟然高达**234s**，出奇的慢，正常来说，一个接口的响应时间超过5秒就必须要优化了，所以本接口已到了必须优化不可的地步，但为了提高测试效率，我这里就只开 10 个线程进行并发访问，优先找出问题很大的优化点。

- 配置JMeter：

  - 线程组配置：

  ![](/images/mvc/testing/线程组配置.png)

  ​	说明：

  ​		1、并发线程数：10 个

  ​		2、线程总启动时间：10 s

  ​		3、循环次数：1 次

  

  - Http请求配置：

  ![](/images/mvc/testing/HTTP配置.png)

  说明：

  ​	1、请求协议：HTTP

  ​	2、请求服务器IP：120.78.59.162

  ​	3、请求端口号：8081

  ​	4、请求方法：GET

  ​	5、请求URL：

  ![](/images/mvc/testing/测试URL.png)

  ​		说明：

  ​			测试启动时，各个线程会随机访问文件里设置好的URL，我这里设的是前5页的URL请求。

  ​	6、响应内容编码：UTF-8



- 测试过程监控

  - 开始时间：2019年4月22日13:01:09

  - 结束时间：2019年4月22日13:09:13

    - 德鲁伊-URL信息

    ![](/images/mvc/testing/URL信息.png)

    说明：

    1. 请求URL：/newsInfo/list

    2. 请求次数：26（包含以往的数据）

    3. 请求时间和：3545878 ms

    4. 最慢一次请求耗时：255670 ms

    5. 执行中的线程：10

    6. 最大并发数：10

    7. jdbc总次数：32

    8. jdbc总耗时：3531258 ms

       

    - 德鲁伊-SQL信息

    ![](/images/mvc/testing/SQL%E4%BF%A1%E6%81%AF.png)

    说明：

    1. 查询sql：

       ```mysql
       SELECT id, title, imgs, content, remarks, create_user_id, create_date, update_user_id,update_date
       FROM tab_news_info
       ORDER BY create_date DESC
       ```

    2. 执行数：16（包含以往数据）

    3. 总执行时间：3506822 ms

    4. 最慢一次查询耗时：252982 ms

    5. 执行中的线程：10

    6. 最大并发数：10

       

    - BootAdmin-堆内存信息

    ![](/images/mvc/testing/堆内存信息.png)

    说明：

    ​	JAVA堆：

    ​		**1、当前堆内存：257MB**

    ​		**2、当前堆内存使用：201MB**

    ​		**3、最大堆内存：466MB**

    ​		**4、堆内存使用线：呈锯齿型，且很密集**

    ​	非堆（方法区）：

    ​		**1、元空间（METASPACE）内存：71.6MB**

    ​		**2、当前非堆内存：118MB**

    ​		**3、当前非堆内存使用：113MB**

    ​		**4、最大非堆内存：存1.33GB**

     		**5、堆内存使用线：基本是直线型**

    

    - BootAdmin-GC信息

    ![](/images/mvc/testing/GC信息.png)

    ​	说明：

    ​		1、GC总次数：256

    ​		2、GC总耗时：3.3660 s

    ​		3、最慢一次GC耗时：0.0110s

    

    - BootAdmin-线程信息

    ![](/images/mvc/testing/线程信息.png)

    ​	说明：

    ​		1、当前运行线程：32

    ​		2、守护线程：26

    ​		3、顶峰运行线程：33

    

    - BootAdmin-CPU信息

    ![](/images/mvc/testing/CPU信息.png)

    ​	说明：

    ​		1、进程ID：1505

    ​		2、CPU使用率：9%

    

    - ECS服务器信息

    ![](/images/mvc/testing/ECS信息.png)

    

#### 3、测试后

- 德鲁伊-URL信息

![](/images/mvc/finish/URL信息.png)

说明：

1. 请求URL：/newsInfo/list

2. 请求次数：26（包含以往的数据）

3. 请求时间和：8203988 ms

4. 最慢一次请求耗时：483459 ms

5. 执行中的线程：0

6. 最大并发数：10

7. jdbc总次数：52

8. jdbc总耗时：8181347 ms

   

- 德鲁伊-SQL信息

![](/images/mvc/finish/SQL信息.png)

说明：

1. 查询sql：

   ```mysql
   SELECT id, title, imgs, content, remarks, create_user_id, create_date, update_user_id,update_date
   FROM tab_news_info
   ORDER BY create_date DESC
   ```

2. 执行数：26（包含以往数据）

3. 总执行时间：8142257 ms

4. 最慢一次查询耗时：482022 ms

5. 执行中的线程：0

6. 最大并发数：10

   

- BootAdmin-堆内存信息

![](/images/mvc/finish/堆内存信息.png)

说明：

​	JAVA堆：

​		**1、当前堆内存：298MB**

​		**2、当前堆内存使用：227MB**

​		**3、最大堆内存：466MB**

​		**4、堆内存使用线：呈锯齿型，十分密集**

​	非堆（方法区）：

​		**1、元空间（METASPACE）内存：71.7MB**

​		**2、当前非堆内存：119MB**

​		**3、当前非堆内存使用：114MB**

​		**4、最大非堆内存：存1.33GB**

​		**5、堆内存使用线：基本是直线型**



- BootAdmin-GC信息

![](/images/mvc/finish/GC信息.png)

​	说明：

​		1、GC总次数：307

​		2、GC总耗时：4.3200 s

​		3、最慢一次GC耗时：0.0060s



- BootAdmin-线程信息

![](/images/mvc/finish/线程信息.png)

​	说明：

​		1、当前运行线程：32

​		2、守护线程：26

​		3、顶峰运行线程：33



- BootAdmin-CPU信息

![](/images/mvc/finish/CPU信息.png)

​	说明：

​		1、进程ID：1505

​		2、CPU使用率：6%



- ECS服务器信息

![](/images/mvc/finish/ECS信息.png)



  - JMeter-聚合报告

    ![](/images/mvc/finish/聚合报告.png)

    说明：

    ​		**1、平均耗时：466280 ms**

    **​		2、最大耗时：483758 ms**

    ​		**3、最小耗时：444002 ms**

    ​		**4、吞吐量：1.2/min**

    ​		**5、无测试异常**

    

# 三、测试数据汇总分析

## 1、测试时间分析

分析：

- 开始时间：2019年4月22日13:01:09
- 结束时间：2019年4月22日13:09:13
- 总测试时间（结束时间-开始时间）：8分04 秒 = 484秒 = 484000 毫秒

**小结：手动记录的时间虽然有些误差，但10个线程的一次并发访问就测了8分钟，响应时间实在太长了，必须要优化！**

## 2、URL数据分析

|     数据/测试时间段      |      测试前      |        测试时        |        测试后        |
| :----------------------: | :--------------: | :------------------: | :------------------: |
|           URL            |  /newsInfo/list  |    /newsInfo/list    |    /newsInfo/list    |
|      请求次数（次）      | 18（以往的数据） | 26（包含以往的数据） | 26（包含以往的数据） |
|     请求时间和（ms）     |     3545878      |       3545878        |       8203988        |
| 最慢的一次请求耗时（ms） |      255670      |        255670        |        483459        |
|    执行中的线程（个）    |        0         |          10          |          0           |
|     最大并发数（个）     |        5         |          10          |          10          |
|        jdbc总次数        |        32        |          32          |          52          |
|     jdbc总耗时（ms）     |     3531258      |       3531258        |       8181347        |

分析：

- 整个测试过程的URL请求次数（测试后-测试前）：10次

  ​		成功请求数约为 10 / (10x1)x100% = 100%。

- 请求时间和（测试后-测试前）：4658110 毫秒

- 平均请求时间（请求时间和/请求测试和）：465811 毫秒

- 测试过程中最慢的一次URL请求耗时：483459 毫秒

- 测试过程中观测到的线程执行数：10 

- 测试过程中的最大线程并发数：10

- 测试过程中JDBC总次数（测试后-测试前）：20

- 测试过程中JDBC总耗时（测试后-测试前）：4650089 毫秒 ≈ 4650 秒 

- 测试过程中平均JDBC耗时（总耗时/总次数）：232504.45 毫秒  ≈ 232 秒

- 测试请求失败率：0%

**小结：URL请求的响应时间太长，平均高达 4658110 毫秒，且大部分时间耗在了 jdbc 查询上，平均JDBC时间高达232504.45 毫秒，说明SQL语句存在严重问题！**

## 3、SQL数据分析

|        数据/测试时间段        |                            测试前                            |       测试时       |       测试后       |
| :---------------------------: | :----------------------------------------------------------: | :----------------: | :----------------: |
|            查询SQL            | SELECT id,title,imgs,content,remarks,create_user_id,create_date,update_user_id,update_date FROM tab_news_info ORDER BY create_date DESC LIMIT 0,10 |         同         |         同         |
|        SQL执行数（条）        |                        16（以往数据）                        | 16（包含以往数据） | 26（包含以往数据） |
|       总执行时间（ms）        |                           3506822                            |      3506822       |      8142257       |
| 测试过程中最慢一次SQL查询耗时 |                            252982                            |       252982       |       482022       |
|      执行中的线程（个）       |                              0                               |         10         |         0          |
|       最大并发数（个）        |                              5                               |         10         |         10         |

分析：

- SQL执行条数（测试后-测试前）：10
- SQL总执行时间（测试后-测试前）：4635435 ms
- 平均SQL执行时间（总执行时间/总执行次数）：463543.5 ms
- 测试过程中最慢一次SQL查询耗时：482022 ms
- 测试过程中的线程执行数：10 
- 测试过程中的最大线程并发数：10

**小结：**

- **SQL执行率（SQL执行次数/URL请求次数）：10/10x100%=100%，每一次查询都走一次数据库，数据库压力很大！**

- **平均SQL查询耗时太大，高达 463543.5 毫秒，证明查询的SQL语句存在很大的问题，急需优化！**

  

Mysql Explian命令分析Sql语句：

![](/images/mvc/Explian信息.png)

SQL查询计划分析：

- select_type（SQL复杂度）：SIMPLE，简单SQL语句，不包含子查询或UNION联合查询。
- type（查询类型）：ALL，全表查询。【**非常严重，需要优化**】
- possible_keys（可能用到的索引）：null。【**非常严重，需要优化**】
- key（实际用到的索引）：null。【**非常严重，需要优化**】
- rows（大概读取的行数）：931.【**非常严重，接近全部数据的2/3，需要优化**】
- Extra（附加信息）：Using filesort，表示MySQL中无法利用索引完成排序，只能依赖于外部的文件进行排序。【**非常严重，需要优化**】

**SQL分析总结：**

​	根据SQL分析，结合我所知的关于Mysql优化相关知识可知，该查询SQL存在非常严重问题，没有索引，且是全表扫描，还用了外部文件做排序，大体可以认为就是它导致了系统的龟速响应！

## 4、堆内存数据分析

JAVA堆：

|     数据/测试时间段      | 测试前 |    测试时    |     测试后     |
| :----------------------: | :----: | :----------: | :------------: |
|   当前堆内存大小（MB）   |  257   |     257      |      298       |
| 当前堆内存使用大小（MB） |  130   |     201      |      227       |
|   最大堆内存大小（MB）   |  466   |     466      |      466       |
|       堆内存使用线       | 波浪型 | 波浪型，密集 | 波浪型，很密集 |

分析：

- 测试过程中当前堆内存变化：257 -> 298，扩容了 41 MB
- 测试过程中堆内存使用变化：130 -> 201 -> 227，堆内使用存持续增加
- 测试过程中最大堆内存变化：一直是 466MB，不变。
- 测试过程中堆内存使用线：锯齿型

**小结：**

​	1、测试过程中Java堆内存发生了明细扩容，扩容会降低系统响应时间，需要对JVM进行优化，避免扩容带来的性能损失。

​	2、测试过程中堆内存的使用一直小于最大堆内存，没有发生内存溢出。

​	3、测试过程中堆内存使用线上下变化十分密集，说明 JVM 一直在频繁的GC，这会大幅降低系统的响应速度，需要结合GC日志对JVM进行优化。



非堆（方法区）：

|      数据/测试时间段       |   测试前   |   测试时   |   测试后   |
| :------------------------: | :--------: | :--------: | :--------: |
|      元空间大小（MB）      |    71.3    |    71.6    |    71.7    |
|   当前非堆内存大小（MB）   |    117     |    118     |    119     |
| 当前非堆内存使用大小（MB） |    112     |    113     |    114     |
|   最大非堆内存大小（GB）   |    1.33    |    1.33    |    1.33    |
|       非堆内存使用线       | 基本是直线 | 基本是直线 | 基本是直线 |

分析：

- 测试过程中元空间内存变化：71.3 -> 71.6，变化不大
- 测试过程中非堆内存变化：117 -> 119，扩容了 2 MB
- 测试过程中非堆内存使用变化：112 -> 113，稍微增加了一点
- 测试过程中最大非堆内存变化：一直是 1.33 GB，不变
- 测试过程中非堆内存使用线：基本是直线型，变化不大。

**小结：**

​	测试过程中，非堆内存的使用变化不大，但还是发生了扩容，多少都会影响系统性能，需要优化。



## 5、GC数据分析

|   数据/测试时间段   | 测试前 | 测试时 | 测试后 |
| :-----------------: | :----: | :----: | :----: |
|   GC总次数（次）    |  194   |  256   |  307   |
|    GC总耗时（s）    | 3.0000 | 3.3660 | 4.3200 |
| 最慢一次GC耗时（s） | 0.0080 | 0.0110 | 0.0060 |

分析：

- 测试过程中GC发生的次数：307-194 = 113 次
- 测试过程中的GC频率（总GC次数/总测试时间）：113 / 484 = 0.233 次/秒
- 测试过程中GC总耗时：4.3200 - 3.0000 = 1.32 秒
- 测试过程中最慢的一次GC耗时：0.0110 秒

结合GC日志：

![](/images/mvc/GC日志.png)

可知道，从项目运行到日志采集为止：

- 年轻代的GC次数（YGC）：563 次
- 年轻代中GC总耗时（YGCT）：3.716 秒
- 全GC的次数（FGC）：15 次
- 全GC总耗时（FGCT）：2.157 秒
- 所有GC的总耗时（GCT）：5.868 秒

**小结：**

​	通过分析可知，总的GC时间虽然不长，但系统的GC次数过于频繁，测试过程中GC频率高达 0.233 次/秒，即每4秒左右就发生一次GC，如此频繁的GC会导致系统响应速度大幅下降，急需对JVM进行调优。

## 6、运行线程分析

|  数据/测试时间段   | 测试前 | 测试时 | 测试后 |
| :----------------: | :----: | :----: | :----: |
| 当前运行线程（个） |   28   |   32   |   32   |
|   守护线程（个）   |   22   |   26   |   26   |
| 顶峰运行线程（个） |   29   |   33   |   33   |

分析：

- 当前运行线程数变化：28 -> 32
- 守护线程数变化：22 -> 26
- 顶峰运行线程数变化：29 -> 33

**小结：**

​	测试过程中运行线程数有明显增长，符合多线程并发测试的特点。

## 7、CPU数据分析

| 数据/测试时间段 | 测试前 | 测试时 | 测试后 |
| :-------------: | :----: | :----: | :----: |
|     进程ID      |  1505  |  1505  |  1505  |
|    CPU使用率    |   6%   |   9%   |   6%   |

分析：

- 进程ID：都是1505
- CPU使用率变化：6% -> 9% -> 6%

**小结：**

​	1、测试过程中进程ID都是 1505 ，保证了测试的合法性。

​	2、结合 ECS 服务器监控数据可知，CPU使用率在整个测试过程中的都处于较低水平，

​		可知测试效果基本不受CPU的限制。

## 8、JMeter聚合报告分析

|        字段        |  数据  |
| :----------------: | :----: |
| 平均请求耗时（ms） | 466280 |
|  吞吐量（次/秒）   |  0.02  |
|  请求异常率（%）   |   0    |

分析：

​	1、平均每次请求耗时：466280毫秒，即466.28秒，说明系统的处理速度实在太慢。

​	2、吞吐量：0.02，即系统没秒才能处理完0.02个请求，服务器处理简直龟速！

​	3、测试过程中没有异常。

## 9、测试分析总结

1、**SQL语句存在极大问题，导致平均查询时间高达 463543.5 毫秒！**

2、**系统频繁GC，测试过程中GC次数高达 113 次，总耗时 1.32 秒！**

3、**系统吞吐量太低，只有0.02/S，即服务器每秒只能处理0.02个请求，说明系统性能太差。**

4、**SQL查询占URL响应时间百分比：463543.5 / 465811 = 99.51%，说明SQL查询效率很差。**

**总结：**

​	**系统性能很差，响应时间实在太长，需要对系统进行全面优化，重点优化数据库、 SQL语句和JVM，尽可能将平均响应时间降低至令人能接受的范围内，如2秒以内！**

# 四、参考资料

[**JMeter网站并发性测试**](http://www.cnblogs.com/qianzf/p/6923412.html)

[**JMeter之Ramp-up Period（in seconds）说明**](https://www.cnblogs.com/hjhsysu/p/9189897.html)

[**MySql Explian命令详解**](https://www.cnblogs.com/gomysql/p/3720123.html)

《深入理解Java虚拟机》第2版 周志明著

