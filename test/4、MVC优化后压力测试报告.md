# 一、背景

## 1、测试前提

​	经过《简单MVC优化后测试报告》可知，经过对系统的各个部分进行优化，测试接口（URL）的平均响应时间被优化到了 11.5169 毫秒，响应速度已经足够快了，但服务器的并发承载量有点小，由吞吐量可知，理论上的并发承载量只有25左右。

## 2、测试目的

​	现实中上线的系统往往不像测试中的那样，只有10个人的并发量，而是几百或是几千，大公司的系统如淘宝等，在双十一期间的并发量甚至高达几万、几十万，所以一个高效、稳定、能用的系统不仅仅要有足够快的响应速度，还要有能够承受住高并发所带来的压力的能力。由《简单MVC优化后测试报告》可知，优化后的系统的理论并发承载量在25左右，想要进一步提升系统的并发能力，就需要对系统进行并发压力测试，以找出系统的并发瓶颈所在，然后再针对这些瓶颈进行优化，才能整体提高系统的并发性能。

​	所以本次的测试目的就是**找出这个优化后的系统的并发瓶颈所在，为提高系统并发承受能力提供依据。**

# 二、测试

## 1、测试准备

### 1、测试环境

------

- 服务器

  ![](/images/优化后压力测试/服务器配置信息.png)

  - 服务器：阿里云ECS云服务器
  - 运行系统：CentOS 7.3 64位
  - CPU：1 vCPU
  - 内存：2GB(IO优化)
  - 带宽：1MBbps

- JDK

  ![](/images/优化后压力测试/JDK信息.png)

  - JDK：1.8.0_151
  - JVM：HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)

- 被测对象

  - 系统：graduation-project-mvc-optimize（优化版MVC项目）

  - 接口：http://120.78.59.162:8082/newsInfo/list

  - 接口数据：

    ![](/images/优化后压力测试/测试数据.png)

  - 数据源

  ```yaml
  spring:
    #数据源配置
    datasource:
      username: root
      password: 你的密码
      url: jdbc:mysql://120.78.59.162:3308/graduation?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=GMT%2B8&allowMultiQueries=true
      type: com.alibaba.druid.pool.DruidDataSource
      #driver-class-name:springBoot2.x 后驱动程序通过SPI自动注册，并且通常不需要手动加载驱动程序类。
      druid:
        # 下面为连接池的补充设置，应用到上面所有数据源中
        initial-size: 5   #线程池初大小
        min-idle: 5       #线程池最小空闲连接
        max-active: 2000  #线程池最大连接数
  
       # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
        time-between-eviction-runs-millis: 60000
        # 配置一个连接在池中最小生存的时间，单位是毫秒
        min-evictable-idle-time-millis: 300000
        validation-query: SELECT 1 FROM DUAL
        test-while-idle: true
        test-on-borrow: false
        test-on-return: false
        # 打开PSCache，并且指定每个连接上PSCache的大小
        pool-prepared-statements: true
        #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
        max-pool-prepared-statement-per-connection-size: 20
        # SpringBoot 2.x 此处记得去掉 log4j
        filters: stat,wall
        use-global-data-source-stat: true
        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
        connect-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
        # 配置监控服务器
        stat-view-servlet:
          login-username: admin
          login-password: 你的密码
          reset-enable: false
          url-pattern: /druid/*
          # 添加IP白名单
          #allow:
          # 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高
          #deny:
        web-stat-filter:
          # 添加过滤规则
          url-pattern: /*
          # 忽略过滤格式，一定要加上 ""，否则会报错
          exclusions: "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"
  ```


### 2、测试工具：

  Apache-JMeter（5.1.1 r1855137）

### 3、测试计划

由《简单MVC优化后测试报告》可知，在10线程时，接口吞吐量为：24.6次/秒。

所以根据吞吐量的大小制定了如下的测试计划，若是测试过程中没有出现错误，且服务器没崩溃，且平均响应时间在2秒以内，则按以下计划进行测试，若在某一阶段出现错误或服务器崩溃了，又或是平均响应时间超过2秒了，则停止测试，并对测试结果进行分析：

|          |                被测接口                 | 并发量 |
| :------: | :-------------------------------------: | :----: |
| 第一阶段 | http://120.78.59.162:8082/newsInfo/list |   10   |
| 第二阶段 | http://120.78.59.162:8082/newsInfo/list |   15   |
| 第三阶段 | http://120.78.59.162:8082/newsInfo/list |   20   |
| 第四阶段 | http://120.78.59.162:8082/newsInfo/list |   25   |

注意事项：

​	1、在JMeter的线程组配置时，为了避免短时间内启动的线程太多给测试带来不必要的影响，故每个线程的创建至少要预留1秒时间，即10线程的线程组，启动时间至少是10秒，20线程的线程组，启动时间至少是20秒，以此类推。

​	2、在下一阶段测试开始前，需要重启服务器，避免上一次测试带来的影响。

参考：

​	[JMeter之Ramp-up Period（in seconds）说明](https://www.cnblogs.com/hjhsysu/p/9189897.html)

### 4、测试数据维度

- URL请求信息
- 运行线程信息
- CPU信息
- 堆内存信息
- ECS服务器信息：
  - CPU使用率
  - 网络带宽（入方向/出方向）
  - 因为已明确知道请求的接口不涉及任何磁盘IO操作，所以就不记录磁盘相关的信息了。
- JMeter测试结果

​	

说明：

因为是并发压力测试，所以本测试重点观测以上列出的维度信息，不再对SQL、GC等响应优化相关的维度进行记录。



## 2、测试前数据

### 1、10线程

- JMeter配置

  - 测试理论

    根据[JMeter之Ramp-up Period（in seconds）说明](https://www.cnblogs.com/hjhsysu/p/9189897.html)可得以下参数：

    T：线程组启动时间

    n：线程组的线程数

    S：最后一个线程的启动时刻

    a：理论上达到并发访问效果所需的循环次数

    t：测试接口的平均响应时间

    R：单个线程运行时间

    

    由《简单MVC优化后测试报告》可知，t=0.166 s，因n=10，则设T=10，则有：

    ​	S = (T- T/n) = (10-10/10) = 9

    ​	a*t > S => a > S/t，即  a > 9/0.166≈55

    ​	即循环次数至少为 55次才能保证这10个线程并发访问测试接口，为了方便观测，我就将循环次数设为1000次，由R = a*t=166，得：

    ​	**并发时间段为：第9秒~第166秒。**

    

  - 线程组配置

  ![](/images/优化后压力测试/10线程/线程组配置.png)

  说明：

  ​	1、线程数：10个

  ​	2、启动时间：10秒

  ​	3、循环次数：1000 次

  

  - HTTP配置

    - URL配置

      ![](/images/优化后压力测试/10线程/HTTP配置.png)

    - URL数据

    ![](/images/优化后压力测试/测试数据.png)

    - 超时配置

      ![](/images/优化后压力测试/10线程/超时配置.png)

      说明：

      ​	由于测试接口的响应速度已经够快了，为了防止并发测试下网络拥塞导致 JMeter 卡死，这里设置了超时时间：

      ​	请求超时：60秒

      ​	响应超时：60秒

      

- URL信息

  ![](/images/优化后压力测试/10线程/测试前/URL信息.png)

  说明：

  ​	1、请求次数：10

  ​	2、请求时间和：714

  ​	3、最大并发数：1



- 运行线程信息

![](/images/优化后压力测试/10线程/测试前/线程信息.png)

​		说明：

​			1、活跃线程数：30

​			2、守护线程数：8

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/10线程/测试前/CPU信息.png)

​		说明：

​			1、PID：12722

​			2、当前CPU使用率：8%



- 堆内存信息

![](/images/优化后压力测试/10线程/测试前/堆内存信息.png)

​	说明：

​		1、最大堆内存使用：400 MB 以下。

​		2、最大非堆内存使用：150 MB 以下。



- ECS服务器信息

![](/images/优化后压力测试/10线程/测试前/ECS信息.png)

说明：

​	1、CPU使用率：50 % 以下。

​	2、网络带宽（入）：100 kb/s 以下。

​	3、网络带宽（出）：300 kb/s 以下。



### 2、15线程

- JMeter配置

  - 测试理论

    根据[JMeter之Ramp-up Period（in seconds）说明](https://www.cnblogs.com/hjhsysu/p/9189897.html)可得以下参数：

    T：线程组启动时间

    n：线程组的线程数

    S：最后一个线程的启动时刻

    a：理论上达到并发访问效果所需的循环次数

    t：测试接口的平均响应时间

    R：单个线程运行时间

    

    由《简单MVC优化后测试报告》可知，t=0.166 s，因n=15，则设T=15，则有：

    ​	S = (T- T/n) = (15-15/15) = 14

    ​	a*t > S => a > S/t，即  a > 14/0.166≈85

    ​	即循环次数至少为 85 次才能保证这15个线程并发访问测试接口，为了方便观测，就将循环次数设为1000次，由R = a*t=166，得：

    **并发时间段为：第14秒~第166秒。**

    

  - 线程组配置

  ![](/images/优化后压力测试/15线程/线程组配置.png)

  说明：

  ​	1、线程数：15 个

  ​	2、启动时间：15 秒

  ​	3、循环次数：1000 次

  

  - HTTP配置

    - URL配置

      ![](/images/优化后压力测试/15线程/HTTP配置.png)

    - URL数据

    ![](/images/优化后压力测试/测试数据.png)

    - 超时配置

      ![](/images/优化后压力测试/15线程/超时配置.png)

      说明：

      ​	请求超时：60秒

      ​	响应超时：60秒

- URL信息

  ![](/images/优化后压力测试/15线程/测试前/URL信息.png)

  说明：

  ​	1、请求次数：10

  ​	2、请求时间和：707

  ​	3、最大并发数：1



- 运行线程信息

![](/images/优化后压力测试/15线程/测试前/线程信息.png)

​		说明：

​			1、活跃线程数：30

​			2、守护线程数：7

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/15线程/测试前/CPU信息.png)

​		说明：

​			1、PID：12712

​			2、当前CPU使用率：10%



- 堆内存信息

![](/images/优化后压力测试/15线程/测试前/堆内存信息.png)

​	说明：

​		1、最大堆内存使用：400 MB 以下。

​		2、最大非堆内存使用：150 MB 以下。



- ECS服务器信息

![](/images/优化后压力测试/15线程/测试前/ECS信息.png)

说明：

​	1、CPU使用率：50% 以下

​	2、网络带宽（入）：200KB/s 以下

​	3、网络带宽（出）：500 kb/s 以下



### 3、20线程

- JMeter配置

  - 测试理论

    根据[JMeter之Ramp-up Period（in seconds）说明](https://www.cnblogs.com/hjhsysu/p/9189897.html)可得以下参数：

    T：线程组启动时间

    n：线程组的线程数

    S：最后一个线程的启动时刻

    a：理论上达到并发访问效果所需的循环次数

    t：测试接口的平均响应时间

    R：单个线程运行时间

    

    由《简单MVC优化后测试报告》可知，t=0.166 s，因n=20，则设T=20，则有：

    ​	S = (T- T/n) = (20-20/20) = 19

    ​	a*t > S => a > S/t，即  a > 19/0.166≈115

    ​	即循环次数至少为 115 次才能保证这20个线程并发访问测试接口，为了方便观测，就将循环次数设为1000次，由R = a*t=166，得：

    **并发时间段为：第19秒~第166秒。**

    

  - 线程组配置

  ![](/images/优化后压力测试/20线程/线程组配置.png)

  说明：

  ​	1、线程数：20个

  ​	2、启动时间：20秒

  ​	3、循环次数：1000 次

  

  - HTTP配置

    - URL配置

    ![](/images/优化后压力测试/20线程/HTTP配置.png)

    - URL数据

    ![](/images/优化后压力测试/测试数据.png)

    - 超时配置

      ![](/images/优化后压力测试/20线程/超时配置.png)

      说明：

      ​	请求超时：60秒

      ​	响应超时：60秒

- URL信息

  ![](/images/优化后压力测试/20线程/测试前/URL信息.png)

  说明：

  ​	1、请求次数：10

  ​	2、请求时间和：1355

  ​	3、最大并发数：1



- 运行线程信息

![](/images/优化后压力测试/20线程/测试前/线程信息.png)

​		说明：

​			1、活跃线程数：30

​			2、守护线程数：8

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/20线程/测试前/CPU信息.png)

​		说明：

​			1、PID：12720

​			2、当前CPU使用率：10%



- 堆内存信息

![](/images/优化后压力测试/20线程/测试前/堆内存信息.png)

​	说明：

​		1、最大堆内存使用：400 MB 以下。

​		2、最大非堆内存使用：150 MB 以下。



- ECS服务器信息

![](/images/优化后压力测试/20线程/测试前/ECS信息.png)

说明：

​	1、CPU使用率：50% 以下

​	2、网络带宽（入）：200 KB/s 以下

​	3、网络带宽（出）：500 kb/s 以下

## 3、测试时数据

### 1、10线程

- 时间

  - 开始时间：2019年5月6日20:05:33
  - 并发时间段：**第9秒~第166秒**
  - 记录时间：2019年5月6日20:06:46
  - 结束时间：2019年5月6日20:11:59

- URL信息

  ![](/images/优化后压力测试/10线程/测试时/URL信息.png)

  说明：

  ​	1、请求次数：1932

  ​	2、请求时间和：30296

  ​	3、最大并发数：9

  ​	



- 运行线程信息

![](/images/优化后压力测试/10线程/测试时/线程信息.png)

​			说明：

​			1、活跃线程数：30

​			2、守护线程数：8

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/10线程/测试时/CPU信息.png)

​		说明：

​			1、PID：12722

​			2、当前CPU使用率：50%



- 堆内存信息

![](/images/优化后压力测试/10线程/测试时/堆内存信息.png)

说明：

​	1、堆内存使用：400 MB 以下

​	2、非堆内存使用：150 MB 以下



- ECS服务器信息

![](/images/优化后压力测试/10线程/测试时/ECS信息.png)

说明：

​	1、CPU使用率：25% 以下

​	2、网络带宽（入）：200 KB/s 以下

​	3、网络带宽（出）：400 kb/s 以下



### 2、15线程

- 时间
  - 开始时间：2019年5月6日20:34:06
  - 并发时间段：**第14秒~第166秒**
  - 记录时间：2019年5月6日20:35:08
  - 结束时间：2019年5月6日20:44:03

- URL信息

  ![](/images/优化后压力测试/15线程/测试时/URL信息.png)

  说明：

  ​	1、请求次数：1983

  ​	2、请求时间和：31832

  ​	3、最大并发数：8

  ​	

- 运行线程信息

![](/images/优化后压力测试/15线程/测试时/线程信息.png)

​			说明：

​			1、活跃线程数：29

​			2、守护线程数：7

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/15线程/测试时/CPU信息.png)

​		说明：

​			1、PID：12712

​			2、当前CPU使用率：52%



- 堆内存信息

![](/images/优化后压力测试/15线程/测试时/堆内存信息.png)

说明：

​	1、堆内存使用：400 MB 以下

​	2、非堆内存使用：150 MB 以下



- ECS服务器信息

![](/images/优化后压力测试/15线程/测试时/ECS信息.png)

说明：

​	1、CPU使用率：50% 以下

​	2、网络带宽（入）：200 KB/S 以下

​	3、网络带宽（出）：500 KB/S 以下

### 3、20线程

- 时间

  - 开始时间：2019年5月6日21:06:48

  - 并发时间段：**第19秒~第166秒**

  - 记录时间：2019年5月6日21:08:06

  - 结束时间：2019年5月6日21:20:05

    

- URL信息

  ![](/images/优化后压力测试/20线程/测试时/URL信息.png)

  说明：

  ​	1、请求次数：2058

  ​	2、请求时间和：38022

  ​	3、最大并发数：10

  ​	



- 运行线程信息

![](/images/优化后压力测试/20线程/测试时/线程信息.png)

​			说明：

​			1、活跃线程数：29

​			2、守护线程数：7

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/20线程/测试时/CPU信息.png)

​		说明：

​			1、PID：12720

​			2、当前CPU使用率：56%



- 堆内存信息

![](/images/优化后压力测试/20线程/测试时/堆内存信息.png)

说明：

​	1、堆内存使用：400 MB 以下

​	2、非堆内存使用：150 MB 以下



- ECS服务器信息

![](/images/优化后压力测试/20线程/测试时/ECS信息.png)

说明：

​	1、CPU使用率：50% 以下

​	2、网络带宽（入）：200 KB/S 以下

​	3、网络带宽（出）：500 KB/S 以下

## 4、测试后数据

### 1、10线程

- URL信息

![](/images/优化后压力测试/10线程/测试后/URL信息.png)

说明：

​	1、请求次数：10010

​	2、请求时间和：123748

​	3、最大并发数：9



- 运行线程信息

![](/images/优化后压力测试/10线程/测试后/线程信息.png)

​		说明：

​			1、活跃线程数：30

​			2、守护线程数：8

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/10线程/测试后/CPU信息.png)

​		说明：

​			1、PID：12722

​			2、当前CPU使用率：11%



- 堆内存信息

![](/images/优化后压力测试/10线程/测试后/堆内存信息.png)

说明：

​	1、java堆内存使用：400 MB以下

​	2、非堆内存使用：150 MB以下



- ECS服务器信息

![](/images/优化后压力测试/10线程/测试后/ECS信息.png)

​	说明：

​		1、CPU使用率：60%以下

​		2、网络带宽（入）：200 kb/s 以下

​		2、网络带宽（出）：已达极限的1MB/s



- JMeter测试结果

  ![](/images/优化后压力测试/10线程/聚合报告.png)

  说明：

  ​	1、样本数：1万

  ​	2、平均响应时间：366 毫秒

  ​	3、吞吐量：25.9次/秒

  ​	4、请求异常：0%


### 2、15线程

- URL信息

![](/images/优化后压力测试/15线程/测试后/URL信息.png)

说明：

​	1、请求次数：15010

​	2、请求时间和：173719

​	3、最大并发数：8



- 运行线程信息

![](/images/优化后压力测试/15线程/测试后/线程信息.png)

​		说明：

​			1、活跃线程数：29

​			2、守护线程数：7

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/15线程/测试后/CPU信息.png)

​		说明：

​			1、PID：12712

​			2、当前CPU使用率：11%



- 堆内存信息

![](/images/优化后压力测试/15线程/测试后/堆内存信息.png)

说明：

​	1、堆内存使用：400MB以下

​	2、非堆内存使用：150 MB以下



- ECS服务器信息

![](/images/优化后压力测试/15线程/测试后/ECS信息.png)

说明：

​	1、CPU使用率：50% 以下

​	2、网络带宽（入）：300 KB/s 以下

​	3、网络带宽（出）：测试时长时间保持在极限的1MB/S



- JMeter测试结果

![](/images/优化后压力测试/15线程/聚合报告.png)

说明：

​	1、样本数：1.5万

​	2、平均响应时间：550 毫秒

​	3、吞吐量：25.1 次/秒

​	4、请求异常：0%



### 3、20线程

- URL信息

![](/images/优化后压力测试/20线程/测试后/URL信息.png)

说明：

​	1、请求次数：20010

​	2、请求时间和：240586

​	3、最大并发数：10



- 运行线程信息

![](/images/优化后压力测试/20线程/测试后/线程信息.png)

​		说明：

​			1、活跃线程数：30

​			2、守护线程数：8

​			3、最大活跃线程数：31



- CPU信息

![](/images/优化后压力测试/20线程/测试后/CPU信息.png)

​		说明：

​			1、PID：12720

​			2、当前CPU使用率：10%



- 堆内存信息

![](/images/优化后压力测试/20线程/测试后/堆内存信息.png)

说明：

​	1、堆内存使用：400 MB以下

​	2、非堆内存使用：150 MB以下



- ECS服务器信息

![](/images/优化后压力测试/20线程/测试后/ECS信息.png)

说明：

​	1、CPU使用率：60%以下

​	2、网络带宽（入）：300 KB/S 以下

​	3、网络带宽（出）：测试期间长时间保持在极限的 1MB/S



- JMeter测试结果

![](/images/优化后压力测试/20线程/聚合报告.png)

说明：

​	1、样本数：2万

​	2、平均响应时间：738 毫秒

​	3、吞吐量：25.2次/秒

​	4、请求异常：0.03 %



- 异常信息

  - JMeter错误信息

    ![](/images/优化后压力测试/20线程/异常信息1.png)

    ![](/images/优化后压力测试/20线程/异常信息2.png)

    说明：

    ​	5个异常都报相同的错误，Load time 分别为：60583、75323、61313、90136、75394。

    

  - JSON断言

    ![](/images/优化后压力测试/20线程/JSON断言.png)

  ​	说明：

  ​		所有断言异常都一样。

  

  - 服务器错误日志

    ```
    无错误日志。
    ```

    

- 异常分析

  由以上异常信息可知：

  ​	1、这不是服务器的内部异常。

  ​	2、所有异常的Load time 都大于预设的 60秒。

  

  因为超时时间已经设得够长（60S），再加长超时时间的意义不大，所以异常的可能原因如下：

  ​	1、网络延迟导致长时间等待超时。

  ​	2、服务器响应带宽不足导致响应拥塞，造成等待超时。

  

  参考：[JMeter测试问题：java.net.SocketTimeoutException: connect timed out，Read timed out](https://blog.csdn.net/ceo158/article/details/9251825)



# 三、分析与总结

## 1、URL数据分析

|                   属性/线程组                    |   10线程    |   15线程    |    20线程    |
| :----------------------------------------------: | :---------: | :---------: | :----------: |
|           请求次数【测试前、后】（次）           |  10、10010  |  10、15010  |  10、20010   |
|          请求时间和【测试前、后】（ms）          | 714、123748 | 707、173719 | 1355、240586 |
|          最大并发数【测试前、后】（个）          |    1、9     |    1、8     |    1、10     |
| 平均请求耗时【测试时间和/测试请求次数】（次/ms） |   12.303    |   11.534    |    11.962    |

分析：

​	1、URL理论请求并发数与实际请求并发数不同，可能原因：

​		（1）网络延迟导致请求到达服务器快慢不一。

​		（2）服务器带宽问题，导致请求到达服务器快慢不一。

​		（3）服务器资源耗尽，处理不了那么多理论上的并发数。

​	2、平均请求耗时变化很小，基本稳定。



## 2、运行线程数据分析

|              属性/线程组               |   10线程   |   15线程   |   20线程   |
| :------------------------------------: | :--------: | :--------: | :--------: |
|   活跃线程数【测试前、时、后】（个）   | 30、30、30 | 30、29、29 | 30、29、30 |
|   守护线程数【测试前、时、后】（个）   |  8、8、8   |  7、7、7   |  8、7、8   |
| 最大活跃线程数【测试前、时、后】（个） | 31、31、31 | 31、31、31 | 31、31、31 |

说明：

​	1、测试过程中各线程组的线程数基本保持一致。



## 3、CPU数据分析

|         属性/线程组         |    10线程    |    15线程     |    20线程     |
| :-------------------------: | :----------: | :-----------: | :-----------: |
|             PID             |    12722     |     12712     |     12720     |
| CPU使用率（测试前、时、后） | 8%、50%、11% | 10%、52%、11% | 10%、56%、10% |

分析：

​	1、不同线程组的PID（进程id）发生变化是因为每测完一个线程组后，都要重启一下服务器，以免上一次的测试影响到下一次。

​	2、CPU使用率在测试时间段内普遍升高，最高不超过60%。

​	3、测试时间段内，CPU使用率随着线程组线程数的增大而增大，但也没超过60%。



## 4、堆内存数据分析

|              属性/线程组               |     10线程      |     15线程      |            20线程            |
| :------------------------------------: | :-------------: | :-------------: | :--------------------------: |
| Java堆内存使用【测试前、时、后】（MB） | 都在400MB 以下  | 都在400MB 以下  | 都在400MB 以下都在400MB 以下 |
|  非堆内存使用【测试前、时、后】（MB）  | 都在150 MB 以下 | 都在150 MB 以下 |       都在150 MB 以下        |

分析：

​	各个线程组，整个测试过程中，Java堆内存使用都在400MB以下（最大805MB），非堆内存使用都在140MB以下（最大1.46GB），都在服务器的承受范围之内。



## 5、ECS监控数据分析

|             属性/线程组              | 10线程 | 15线程 | 20线程 |
| :----------------------------------: | :----: | :----: | :----: |
|     测试过程中CPU最高使用率（%）     |   60   |   60   |   60   |
| 测试过程中带宽（入）最高使用（kb/s） |  200   |  300   |  300   |
| 测试过程中带宽（出）最高使用（kb/s） |  1024  |  1024  |  1024  |



分析：

​	1、测试过程中CUP使用率和网络带宽（入方向）的占用都在系统可承受范围之内，对测试影响不大。

​	2、网络带宽（出方向）在线程数只有10时，测试过程中便已达到了极限的1MB/S，在后面的其他线程组测试中，也都被这个极限带宽所限制。



## 6、JMeter聚合报告分析

### 1、结果分析

|    数据/线程组     | 10线程 | 15线程 |   20线程   |
| :----------------: | :----: | :----: | :--------: |
|    样本数（万）    |   1    |  1.5   |     2      |
| 平均响应时间（ms） |  366   |  550   |    738     |
|  吞吐量（次/秒）   |  25.9  |  25.1  |    25.2    |
|  请求异常率（%）   |   0%   |   0%   |   0.03 %   |
|      测试状态      | 无异常 | 无异常 | 0.03 %异常 |

分析：

​	1、吞吐量基本在25次/秒左右。

​	2、随着线程组的线程数量增加，平均响应时间也增加，当线程组的线程数达到20时，请求出现了0.03%的超时异常。



### 2、异常分析

1、JMeter报错分析

- 根据 JMeter的错误信息可知，这不是服务器内部的异常。
- 结合服务器网络带宽（出方向）的使用情况，大概可推测出，这是由于服务器出带宽被用满，导致服务器响应数据给 JMeter 时网络拥塞，造成 JMeter 等待响应超时。



## 7、总结

​	由各个线程组的测试数据可知，在测试过程中，CPU、内存、线程等数据虽然有变化，但整体都在服务器的可承受范围之内，对测试结果并未产生什么影响，目前可确认能限制系统最大并发量的只有网络带宽，1MB/S的带宽实在太小，理论上能有25的吞吐量，在实际测试时，线程数到20就报响应超时异常了。

解决方案：

​	**提高服务器的带宽。**



# 四、错误处理

- JMeter报错如下：

  ```java
  java.net.SocketTimeoutException: connect timed out，Read timed out
  ```

  可能原因分析：

  ​	1、根据错误信息可知，这是JMeter在测试时连接超时与读取超时导致。

  ​	2、服务器那边未处理该线程的请求，或者为保证服务能力，断掉了连接。

  

  解决办法：

  ​	1、提高JMeter的HTTP配置中的超时时间。

  ​	2、排查服务器错误日志。

  

  参考：

  [jmeter性能测试java.net.SocketTimeoutException: connect timed out，Read timed out](https://www.cnblogs.com/huamei2008/p/8677016.html)

  [JMeter测试问题：java.net.SocketTimeoutException: connect timed out，Read timed out](https://blog.csdn.net/ceo158/article/details/9251825)

  

- JMeter报错如下：

  ```java
  Connection reset by peer: socket write error
  ```

  可能原因分析：

  ​	查阅相关资料可知，这是因为JMeter请求连接被重置导致的问题。

  解决办法：

  ```
  1.修改HTTP请求下面的Impementation选项，改成HttpClient4
  
  2.在user.properties文件内修改：
  
  hc.parameters.file=hc.parameters
  
  3.在hc.parameters文件内修改：
  
  http.connection.stalecheck$Boolean=true
  
  重启Jmeter再尝试一下
  ```

  参考：[Jmeter遇到线程链接被重置（Connection reset by peer: socket write error）的解决方法](https://www.cnblogs.com/performancetest/p/5535883.html)



# 五、参考资料

[**JMeter之Ramp-up Period（in seconds）说明**](https://www.cnblogs.com/hjhsysu/p/9189897.html)

[**jmeter性能测试java.net.SocketTimeoutException: connect timed out，Read timed out**](https://www.cnblogs.com/huamei2008/p/8677016.html)

[**JMeter测试问题：java.net.SocketTimeoutException: connect timed out，Read timed out**](https://blog.csdn.net/ceo158/article/details/9251825)

[**Jmeter遇到线程链接被重置（Connection reset by peer: socket write error）的解决方法**](https://www.cnblogs.com/performancetest/p/5535883.html)

[**Jmeter Web 性能测试入门 (七)：Performance 测试中踩过 Jmeter 的坑**](http://www.mamicode.com/info-detail-2103967.html)

[**Jmeter性能结果分析**](https://www.cnblogs.com/xiaoxiaoxuepiao/p/9057211.html)